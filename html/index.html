<html>
	<head>
		<!-- <link rel="stylesheet" type="text/css" href="style/style.css">
		<script src="js/lib/three.min.js"></script> -->
		<!-- <script type="text/javascript" src="js/lib/OBJLoader.js"></script>
		<script src="js/lib/OrbitControls.js"></script>
		<script src="js/lib/jquery-3.1.1.min.js"></script> -->
	</head>
	<body style="margin: 0px">
		<div id="container"></div>
		<audio id='audio-src' src='Prince.wav'></audio>
	<script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
    	//  Simplex 3D Noise 
		//  by Ian McEwan, Ashima Arts
		//
		vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
		vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
		float snoise(vec3 v){ 
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		// First corner
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		// Other corners
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  //  x0 = x0 - 0. + 0.0 * C 
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		// Permutations
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
		             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
		           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
		           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		// Gradients
		// ( N*N points uniformly over a square, mapped onto an octahedron.)
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		//Normalise gradients
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		// Mix final noise value
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
		                                dot(p2,x2), dot(p3,x3) ) );
		}

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float amp0;
        uniform float amp1;
        uniform float amp2;
        uniform float amp3;
        uniform float amp4;
        uniform float amp5;
        uniform float amp6;
        uniform float amp7;

        uniform float amp8;
        uniform float amp9;
        uniform float amp10;
        uniform float amp11;
        uniform float amp12;
        uniform float amp13;
        uniform float amp14;
        uniform float amp15;

        uniform float amp16;
        uniform float amp17;
        uniform float amp18;
        uniform float amp19;
        uniform float amp20;
        uniform float amp21;
        uniform float amp22;
        uniform float amp23;

        uniform float amp24;
        uniform float amp25;
        uniform float amp26;
        uniform float amp27;
        uniform float amp28;
        uniform float amp29;
        uniform float amp30;
        uniform float amp31;

        uniform float amplitude;

        float amps[32];
        

        float getData(int id) {
		    for (int i=0; i<32; i++) {
		        if (i == id) return amps[i];
		    }
		}

        void main() {
            vec2 st = gl_FragCoord.xy/u_resolution.xy;
            //
            //float numberSections = 8.;
            float numberSections = 32.;
            
            amps[0] = amp0;
	        amps[1] = amp1;
	        amps[2] = amp2;
	        amps[3] = amp3;
	        amps[4] = amp4;
	        amps[5] = amp5;
	        amps[6] = amp6;
	        amps[7] = amp7;

	        amps[8] = amp8;
	        amps[9] = amp9;
	        amps[10] = amp10;
	        amps[11] = amp11;
	        amps[12] = amp12;
	        amps[13] = amp13;
	        amps[14] = amp14;
	        amps[15] = amp15;

	        amps[16] = amp16;
	        amps[17] = amp17;
	        amps[18] = amp18;
	        amps[19] = amp19;
	        amps[20] = amp20;
	        amps[21] = amp21;
	        amps[22] = amp22;
	        amps[23] = amp23;

	        amps[24] = amp24;
	        amps[25] = amp25;
	        amps[26] = amp26;
	        amps[27] = amp27;
	        amps[28] = amp28;
	        amps[29] = amp29;
	        amps[30] = amp30;
	        amps[31] = amp31;

            int section = int(floor(st.y*numberSections));

            float appliedAmp = log(getData(section)/128.)*pow(amplitude,4.);

            float noise = snoise(vec3(st.x*10.+u_time,u_time*.01+appliedAmp,st.y*10.))*appliedAmp*.1;
            float noise1 = snoise(vec3(st.x*10.+u_time+10.,u_time*.01+appliedAmp,st.y*10.))*appliedAmp*.1;
            float noise2 = snoise(vec3(st.x*10.+u_time+100.,u_time*.01+appliedAmp,st.y*10.))*appliedAmp*.1;

            float lineR = step(fract(st.y*8.+noise),appliedAmp*.1);
            float lineG = step(fract(st.y*8.-noise1),appliedAmp*.1);
            float lineB = step(fract(st.y*8.+noise2),appliedAmp*.1);
            //line*=
            gl_FragColor=vec4(lineR,lineG,lineB,1.0);
        }
    </script>
		<!-- <script src="js/script.js"></script> -->
		<script src="js/bundle.js"></script>
	</body>
</html>
